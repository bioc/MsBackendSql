% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MsqlBackend-functions.R, R/MsqlBackend.R
\name{MsqlBackend}
\alias{MsqlBackend}
\alias{createMsqlBackendDatabase}
\alias{MsqlBackend-class}
\alias{show,MsBackendCached-method}
\alias{backendInitialize,MsqlBackend-method}
\alias{dataStorage,MsqlBackend-method}
\alias{[,MsqlBackend-method}
\alias{peaksData,MsqlBackend-method}
\alias{peaksVariables,MsqlBackend-method}
\alias{intensity<-,MsqlBackend-method}
\alias{mz<-,MsqlBackend-method}
\alias{$<-,MsqlBackend-method}
\alias{spectraData,MsqlBackend-method}
\alias{reset,MsqlBackend-method}
\alias{spectraNames,MsqlBackend-method}
\alias{spectraNames<-,MsqlBackend-method}
\alias{filterMsLevel,MsqlBackend-method}
\alias{filterRt,MsqlBackend-method}
\title{\code{Spectra} MS backend storing data in a SQL database}
\usage{
MsqlBackend()

createMsqlBackendDatabase(
  dbcon,
  x = character(),
  backend = MsBackendMzR(),
  chunksize = 10L
)

\S4method{show}{MsBackendCached}(object)

\S4method{backendInitialize}{MsqlBackend}(object, dbcon, ...)

\S4method{dataStorage}{MsqlBackend}(object)

\S4method{[}{MsqlBackend}(x, i, j, ..., drop = FALSE)

\S4method{peaksData}{MsqlBackend}(object, columns = c("mz", "intensity"))

\S4method{peaksVariables}{MsqlBackend}(object)

\S4method{intensity}{MsqlBackend}(object) <- value

\S4method{mz}{MsqlBackend}(object) <- value

\S4method{$}{MsqlBackend}(x, name) <- value

\S4method{spectraData}{MsqlBackend}(object, columns = spectraVariables(object))

\S4method{reset}{MsqlBackend}(object)

\S4method{spectraNames}{MsqlBackend}(object)

\S4method{spectraNames}{MsqlBackend}(object) <- value

\S4method{filterMsLevel}{MsqlBackend}(object, msLevel = integer())

\S4method{filterRt}{MsqlBackend}(object, rt = numeric(), msLevel. = integer())
}
\arguments{
\item{dbcon}{Connection to a database.}

\item{x}{For \code{createMsqlBackendDatabase}: \code{character} with the names of the
raw data files from which the data should be imported. For other methods
an \code{MsqlBaackend} instance.}

\item{backend}{For \code{createMsqlBackendDatabase}: MS backend that can be used
to import MS data from the raw files specified with parameter \code{x}.}

\item{chunksize}{For \code{createMsqlBackendDatabase}: \code{integer(1)} defining the
number of input that should be processed per iteration. With
\code{chunksize = 1} each file specified with \code{x} will be imported and its
data inserted to the database. With \code{chunksize = 5} data from 5 files
will be imported (in parallel) and inserted to the database. Thus, higher
values might result in faster database creation, but require also more
memory.}

\item{object}{A \code{MsqlBackend} instance.}

\item{...}{For \code{[}: ignored.}

\item{i}{For \code{[}: \code{integer} or \code{logical} to subset the object.}

\item{j}{For \code{[}: ignored.}

\item{drop}{For \code{[}: \code{logical(1)}, ignored.}

\item{columns}{For \code{spectraData}: \code{character()} optionally defining a subset
of spectra variables that should be returned. Defaults to
\code{columns = spectraVariables(object)} hence all variables are returned.
For \code{peaksData} accessor: optional \code{character} with requested columns in
the individual \code{matrix} of the returned \code{list}. Defaults to
\code{columns = c("mz", "intensity")} but all columns listed by
\code{peaksVariables} would be supported.}

\item{value}{For all setter methods: replacement value.}

\item{name}{For \verb{<-}: \code{character(1)} with the name of the spectra variable
to replace.}

\item{msLevel}{For \code{filterMsLevel}: \code{integer} specifying the MS levels to
filter the data.}

\item{rt}{For \code{filterRt}: \code{numeric(2)} with the lower and upper retention
time. Spectra with a retention time \verb{>= rt[1]} and \verb{<= rt[2]} are
returned.}

\item{msLevel.}{For \verb{filterRt: }integer\verb{with the MS level(s) on which the retention time filter should be applied (all spectra from other MS levels are considered for the filter and are returned *as is*). If not specified, the retention time filter is applied to all MS levels in}object`.}
}
\value{
See documentation of respective function.
}
\description{
The \code{MsqlBackend} is an implementation for the \code{\link[=MsBackend]{MsBackend()}} class for
\code{\link[=Spectra]{Spectra()}} objects which stores and retrieves MS data from a SQL database.
New databases can be created from raw MS data files using
\code{createMsqlBackendDatabase}.
}
\details{
The \code{MsqlBackend} class is in principle a \emph{read-only} backend but by
extending the \code{\link[=MsBackendCached]{MsBackendCached()}} backend from the \code{Spectra} package it
allows changing and adding (\strong{temporarily}) spectra variables \strong{without}
changing the original data in the SQL database.
}
\section{Creation of backend objects}{


SQL databases can be created and filled with MS data from raw data files
using the \code{createMsqlBackendDatabase} function. Existing SQL databases
(created previously with \code{createMsqlBackendDatabase} can be loaded using
the conventional way to create/initialize \code{MsBackend} classes, i.e. using
\code{backendInitialize}.
\itemize{
\item \code{createMsqlBackendDatabase}: create a database and fill it with MS data.
Parameter \code{dbcon} is expected to be a database connection, parameter \code{x} a
\code{character} vector with the file names from which to import the data.
Parameter \code{backend} is used for the actual data import and defaults to
\code{backend = MsBackendMzR()} hence allowing to import data from mzML, mzXML
or netCDF files. Parameter \code{chunksize} allows to define the number of
files (\code{x}) from which the data should be imported in one iteration. With
the default \code{chunksize = 10L} data is imported from 10 files in \code{x} at the
same time (if \code{backend} supports it even in parallel) and this data is then
inserted into the database. Larger chunk sizes will require more memory and
also larger disk space (as data import is performed through temporary
files) but might eventually be faster. While data can be stored in any SQL
database, at present it is suggested to use MySQL/MariaDB databases. For
\code{dbcon} being a connection to a MySQL/MariaDB database, the tables will use
the \emph{ARIA} engine providing faster data access and will use table
partitioning (using by default 10 partitions). Note that, while inserting
the data takes a considerable amount of time, also the subsequent creation
of database indices can take very long (even longer than data insertion).
\item \code{backendInitialize}: get access and initialize a \code{MsqlBackend} object.
Parameter \code{object} is supposed to be a \code{MsqlBackend} instance, created e.g.
with \code{MsqlBackend()}. Parameter \code{dbcon} is expected to be a connection to
a SQL database previously created with the \code{createMsqlBackendDatabase}
function.
}
}

\section{Subsetting and filtering data}{


\code{MsqlBackend} objects can be subsetted using the \code{[} function. Internally,
this will simply subset the \code{integer} vector of the primary keys and
eventually cached data. The original data in the database \strong{is not} affected
by any subsetting operation. Any subsetting operation can be \emph{undone} by
resetting the object with the \code{reset} function. Subsetting in arbitrary
order as well as index replication is supported.

In addition, \code{MsqlBackend} supports all other filtering methods available
through \code{\link[=MsBackendCached]{MsBackendCached()}}. Implementation of filter functions optimized
for \code{MsqlBackend} objects are:
\itemize{
\item \code{filterMsLevel}: filter the object based on the MS levels specified with
parameter \code{msLevel}. The function does the filtering using SQL queries.
If \code{"msLevel"} is a \emph{local} variable stored within the object (and hence
in memory) the default implementation in \code{MsBackendCached} is used instead.
\item \code{filterRt}: filter the object keeping only spectra with retention times
within the specified retention time range (parameter \code{rt}). Optional
parameter \code{msLevel.} allows to restrict the retention time filter only on
the provided MS level(s) returning all spectra from other MS levels.
}
}

\section{Accessing and \emph{modifying} data}{


The functions listed here are specifically implemented for \code{MsqlBackend}. In
addition, \code{MsqlBackend} inherits and supports all data accessor, filtering
functions and data manipulation functions from \code{\link[=MsBackendCached]{MsBackendCached()}}.
\itemize{
\item \code{$}, \verb{$<-}: access or set (add) spectra variables in \code{object}. Spectra
variables added or modified using the \verb{$<-} are \emph{cached} locally within
the object (data in the database is never changed). To restore an object
(i.e. drop all cached values) the \code{reset} function can be used.
\item \code{dataStorage}: returns a \code{character} vector same length as there are
spectra in \code{object} with the name of the database containing the data.
\item \verb{intensity<-}: not supported.
\item \verb{mz<-}: not supported.
\item \code{peaksData}: returns a \code{list} with the spectras' peak data. The length of
the list is equal to the number of spectra in \code{object}. Each element of
the list is a \code{matrix} with columns according to parameter \code{columns}. For
an empty spectrum, a \code{matrix} with 0 rows is returned. Use
\code{peaksVariables(object)} to list supported values for parameter \code{columns}.
\item \code{peaksVariables}: returns a \code{character} with the available peak variables,
i.e. columns that could be queried with \code{peaksData}.
\item \code{reset}: \emph{restores} an \code{MsqlBackend} by re-initializing it with the data
from the database. Any subsetting or cached spectra variables will be lost.
\item \code{spectraData}: gets or general spectrum metadata.  \code{spectraData} returns
a \code{DataFrame} with the same number of rows as there are spectra in
\code{object}. Parameter \code{columns} allows to select specific spectra variables.
\item \code{spectraNames}, \verb{spectraNames<-}: returns a \code{character} of length equal to
the number of spectra in \code{object} with the primary keys of the spectra from
the database (converted to \code{character}). Replacing spectra names with
\verb{spectraNames<-} is not supported.
}
}

\section{Implementation notes}{


Internally, the \code{MsqlBackend} class contains only the primary keys for all
spectra stored in the SQL database. Keeping only these \code{integer} in memory
guarantees a minimal memory footpring of the object. Still, depending of the
number of spectra in the database, this \code{integer} vector might become very
large. Any data access will involve SQL calls to retrieve the data from the
database. By extending the \code{\link[=MsBackendCached]{MsBackendCached()}} object from the \code{Spectra}
package, the \code{MsqlBackend} supports to (temporarily, i.e. for the duration
of the R session) add or modify spectra variables. These are however stored
in a \code{data.frame} within the object thus increasing the memory demand of the
object.
}

\examples{

####
## Create a new MsqlBackend database

## Define a file from which to import the data
data_file <- system.file("microtofq", "MM8.mzML", package = "msdata")

## Create a database/connection to a database
library(RSQLite)
db_file <- tempfile()
dbc <- dbConnect(SQLite(), db_file)

## Import the data from the file into the database
createMsqlBackendDatabase(dbc, data_file)
dbDisconnect(dbc)

## Initialize a MsqlBackend
dbc <- dbConnect(SQLite(), db_file)
be <- backendInitialize(MsqlBackend(), dbc)

be

## Original data source
head(be$dataOrigin)

## Data storage
head(dataStorage(be))

## Access all spectra data
spd <- spectraData(be)
spd

## Available variables
spectraVariables(be)

## Access mz values
mz(be)

## Subset the object to spectra in arbitrary order
be_sub <- be[c(5, 1, 1, 2, 4, 100)]
be_sub

## The internal spectrum IDs (primary keys from the database)
be_sub$spectrum_id_

## Add additional spectra variables
be_sub$new_variable <- "B"

## This variable is *cached* locally within the object (not inserted into the
## database)
be_sub$new_variable
}
\author{
Johannes Rainer
}
